<% //-*- c -*-
%><%@include "includes.csp"
%><%
#define COPYSTR(f) snprintf(prob->f, sizeof(prob->f), "%s", (f))
#define MOVESTR(f) xfree(prob->f); prob->f = f; f = NULL

static unsigned char *
normalize_problem_dir_param(const unsigned char *raw, size_t len)
{
    size_t start = 0;
    while (start < len && (raw[start] <= ' ' || raw[start] == 0x7f)) ++start;
    while (len > start && (raw[len - 1] <= ' ' || raw[len - 1] == 0x7f)) --len;
    if (len <= start) return NULL;
    unsigned char *out = xmalloc(len - start + 1);
    size_t pos = 0;
    for (size_t idx = start; idx < len; ++idx) {
        unsigned char ch = raw[idx];
        if (ch <= ' ' || ch == 0x7f) {
            out[pos++] = ' ';
            while (idx + 1 < len) {
                unsigned char next = raw[idx + 1];
                if (next <= ' ' || next == 0x7f) {
                    ++idx;
                } else {
                    break;
                }
            }
        } else {
            out[pos++] = ch;
        }
    }
    while (pos > 0 && out[pos - 1] == ' ') --pos;
    if (pos == 0) {
        xfree(out);
        return NULL;
    }
    out[pos] = 0;
    return out;
}

%><%@set getter_name = "csp_get_prob_save_id_form"
%><%@set ac_prefix = "SSERV_CMD_"
%><%@set err_prefix = "SSERV_ERR_"
%><%@page csp_view_prob_save_id_form(PageInterface *pg, FILE *log_f, FILE *out_f, struct http_request_info *phr)
%><%@include "stdvars.csp"
%><%
    snprintf(phr->content_type, sizeof(phr->content_type), "application/json; charset=%s", EJUDGE_CHARSET);

    // variables go here
    int prob_id = 0;
    unsigned char *short_name = NULL;
    unsigned char *internal_name = NULL;
    unsigned char *uuid = NULL;
    unsigned char *long_name = NULL;
    unsigned char *super = NULL;
    const unsigned char *type = NULL;
    int variant_num = -1;
    int autoassign_variants = -1;

    int i, j;
    struct section_problem_data *prob = NULL, *other_prob = NULL;
    int type_val;

    char *msg_s = NULL;
    size_t msg_z = 0;
    FILE *msg_f = open_memstream(&msg_s, &msg_z);

    unsigned char **problem_dirs = NULL;
    int problem_dir_count = 0;
    unsigned char *first_problem_dir = NULL;

%><s:read var="prob_id" required="yes" /><%
%><s:read var="short_name" normalize="yes" nonnull="yes" /><%
%><s:read var="internal_name" normalize="yes" /><%
%><s:read var="uuid" normalize="yes" /><%
%><s:read var="long_name" normalize="yes" nonnull="yes" /><%
%><s:read var="super" normalize="yes" nonnull="yes" /><%
%><s:read var="type" /><%
%><s:read var="variant_num" default="-1" /><%
%><s:read var="autoassign_variants" default="-1" /><%

    if (retval || !phr->ss) goto cleanup;

    if (!phr->json) {
        for (i = 0; i < phr->param_num; ++i) {
            if (!strcmp(phr->param_names[i], "problem_dir")) {
                unsigned char *normalized = normalize_problem_dir_param(phr->params[i], phr->param_sizes[i]);
                if (normalized) {
                    problem_dirs = xrealloc(problem_dirs, sizeof(*problem_dirs) * (problem_dir_count + 2));
                    problem_dirs[problem_dir_count++] = normalized;
                    problem_dirs[problem_dir_count] = NULL;
                }
            }
        }
        if (problem_dir_count > 0) {
            first_problem_dir = xstrdup(problem_dirs[0]);
        }
    }

    if (type != NULL) {
        type_val = problem_parse_type(type);
        if (type_val < 0 || type_val >= PROB_TYPE_LAST) type_val = PROB_TYPE_STANDARD;
    } else {
        type_val = PROB_TYPE_STANDARD;
    }
    if (prob_id <= 0) {
        i = -prob_id;
        if (i >= phr->ss->aprob_u) FAIL(SSERV_ERR_INVALID_PARAMETER);
        prob = phr->ss->aprobs[i];
        if (!prob) FAIL(SSERV_ERR_INVALID_PARAMETER);
        if (!*short_name) {
            fprintf(msg_f, "short_name is not set<br/>");
            FAIL(SSERV_ERR_INVALID_PARAMETER);
        }
        other_prob = super_serve_find_problem(phr->ss, short_name);
        if (other_prob && other_prob != prob) {
            fprintf(msg_f, "short_name is not unique<br/>");
            FAIL(SSERV_ERR_INVALID_PARAMETER);
        }
        xfree(internal_name);
        internal_name = NULL;
        xfree(uuid);
        uuid = NULL;
        if (*super) {
            xfree(super);
            super = xstrdup("");
        }
        variant_num = -1;
        autoassign_variants = -1;
    } else {
        i = prob_id;
        if (i >= phr->ss->prob_a) FAIL(SSERV_ERR_INVALID_PARAMETER);
        prob = phr->ss->probs[i];
        if (!prob) FAIL(SSERV_ERR_INVALID_PARAMETER);

        // short_name must be unique
        if (*short_name) {
            other_prob = super_serve_find_problem(phr->ss, short_name);
            if (other_prob && other_prob != prob) {
                fprintf(msg_f, "short_name is not unique<br/>");
                FAIL(SSERV_ERR_INVALID_PARAMETER);
            }
        }
        // internal_name must be unique
        if (internal_name && !*internal_name) {
            xfree(internal_name); internal_name = NULL;
        }
        if (internal_name) {
            other_prob = super_serve_find_problem(phr->ss, internal_name);
            if (other_prob && other_prob != prob) {
                fprintf(msg_f, "internal_name is not unique<br/>");
                FAIL(SSERV_ERR_INVALID_PARAMETER);
            }
        }
        if (*super) {
            for (j = 0; j < phr->ss->aprob_u; ++j) {
                if (!phr->ss->aprobs[j]) continue;
                if (!strcmp(super, phr->ss->aprobs[j]->short_name))
                    break;
            }
            if (j >= phr->ss->aprob_u) {
                fprintf(msg_f, "super problem does not exist<br/>");
                FAIL(SSERV_ERR_INVALID_PARAMETER);
            }
        }
        if (variant_num < 0) variant_num = -1;
        if (autoassign_variants < 0) autoassign_variants = -1;
        if (autoassign_variants > 0) autoassign_variants = 1;
    }

    int normalized_variant_num = variant_num;
    if (normalized_variant_num < 0) normalized_variant_num = 0;
    if (problem_dir_count > 0) {
        if (normalized_variant_num > 1 && problem_dir_count != normalized_variant_num) {
            fprintf(msg_f, "problem_dir entries (%d) must match variant_num (%d)<br/>", problem_dir_count, normalized_variant_num);
            FAIL(SSERV_ERR_INVALID_PARAMETER);
        }
        if (normalized_variant_num <= 1 && problem_dir_count > 1) {
            fprintf(msg_f, "multiple problem_dir entries require variant_num > 1<br/>");
            FAIL(SSERV_ERR_INVALID_PARAMETER);
        }
    }

    if (!retval && phr->ss) {
        COPYSTR(short_name);
        MOVESTR(internal_name);
        MOVESTR(long_name);
        COPYSTR(super);
        MOVESTR(uuid);
        prob->type = type_val;
        prob->variant_num = variant_num;
        prob->autoassign_variants = autoassign_variants;
        sarray_free((char**) prob->variant_problem_dirs);
        prob->variant_problem_dirs = problem_dirs;
        problem_dirs = NULL;
        xfree(prob->problem_dir);
        prob->problem_dir = first_problem_dir;
        first_problem_dir = NULL;
    }

cleanup:;
    fclose(msg_f); msg_f = NULL;
%>
{
    "input" : {
    },
    "retval" : <s:v value="retval" />,
    "messages" : "<s:v value="msg_s" json="yes" checkExpr="" />"
}
<%
    html_armor_free(&ab);
    xfree(msg_s);
    xfree(short_name);
    xfree(internal_name);
    xfree(uuid);
    xfree(long_name);
    xfree(super);
    sarray_free((char**) problem_dirs);
    xfree(first_problem_dir);
%>
